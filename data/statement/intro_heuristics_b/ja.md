(まずは問題Aを先に読んでください。この問題を解くことで得られる得点は1点です。順位にはほぼ影響しません。)

## 入門者向けガイド

まずは入力と出力からスコアを計算するプログラムを作ってみましょう。
スコアは実際に提出すれば合計点は分かりますし、今回のようにローカル実行用のスコア計算プログラムが提供される場合も多くあります。
しかし、問題の仕様を正しく理解出来ているかを確認するのにも役立ちますし、解答プログラムを作成する際やデバッグ時にもソースコードが流用出来ることが多いため、よほど複雑なスコア計算で無い限りは作っておいて損はありません。

## 問題文

$D$ 日分のコンテストの日程が与えられます。
各 $d=1,2,\ldots,D$について、$d$ 日目終了時点での満足度を計算してください。

## 入力

入力は問題Aの入力の末尾に問題Aの出力が続く形で標準入力から与えられる。

> $D$
> 
> $c_1$ $c_2$ $\cdots$ $c_{26}$
> 
> $s_{1,1}$ $s_{1,2}$ $\cdots$ $s_{1,26}$
> 
> $\vdots$
> 
> $s_{D,1}$ $s_{D,2}$ $\cdots$ $s_{D,26}$
> 
> $t_1$
> 
> $t_2$
> 
> $\vdots$
> 
> $t_D$

- 問題Aの入力に該当する部分の制約及び生成方法は問題Aのものと同じである。
- 問題Aの出力に該当する部分は、各 $d$ について $1\leq t_d \leq 26$ を満たし、制約を満たすあらゆる値に対して正しく動作することが期待される。

## 出力

$d$ 日目終了時点での満足度を $v_d$ としたとき、以下のフォーマットで標準出力に出力せよ。

> $v_1$
> 
> $v_2$
> 
> $\vdots$
> 
> $v_D$

```input1
5
86 90 69 51 2 96 71 47 88 34 45 46 89 34 31 38 97 84 41 80 14 4 50 83 7 82
19771 12979 18912 10432 10544 12928 13403 3047 10527 9740 8100 92 2856 14730 1396 15905 6534 4650 11469 3628 8433 2994 10899 16396 18355 11424
6674 17707 13855 16407 12232 2886 11908 1705 5000 1537 10440 10711 4917 10770 17272 15364 19277 18094 3929 3705 7169 6159 18683 15410 9092 4570
6878 4239 19925 1799 375 9563 3445 5658 19857 11401 6997 6498 19933 3848 2426 2146 19745 16880 17773 18359 3921 14172 16730 11157 5439 256
8633 15862 15303 10749 18499 7792 10317 5901 9395 11433 3514 3959 5202 19850 19469 9790 5653 784 18500 10552 17975 16615 7852 197 8471 7452
19855 17918 7990 10572 4333 438 9140 9104 12622 4985 12319 4028 19922 12132 16259 17476 2976 547 19195 19830 16285 4806 4471 9457 2864 2192
1
17
13
14
13
```

```output1
18398
35037
51140
65837
79325
```

この入出力例は問題仕様の確認用の小さいもので、制約 $D=365$ を満たしておらず、実際にテストケースとして与えられることはない。

## 次のステップ

この問題は、1日目に開催するコンテストを決める、2日目に開催するコンテストを決める、… という具合に順番に解を構築していくことが出来、更に構築した部分的な解の良さ(満足度)も計算が出来ます。
そこで、$d$ 日目にはその日の終了時点における満足度が一番高くなるコンテストを選択する、というアルゴリズムを考えることが出来ます。
このような、その瞬間でのベストな選択を繰り返す「貪欲法」は、既にABCなどのアルゴリズムコンテストで出会ったことがあるかもしれません。
貪欲法は問題によっては最適解を達成することが保証出来ますが、残念ながらこの問題に対しては最適解を与えるとは限りません。
しかし、最適解は得られずとも、多くの場合にそれなりに良い解を求めることは出来ます。
問題Aに戻り、今準備したスコア計算プログラムを活用して貪欲法による解答を実装してみましょう。

貪欲法は汎用性が高く実装が簡単な上に、他の手法に比べ比較的高速に動作することも多く、巨大な入力を処理する必要がある場合には最有力の手法となることも多々あります。
また、貪欲な選択の基準(評価関数)を変更したり、その瞬間におけるベストな解一つに絞らずに複数個の候補を残して構築していったり(ビームサーチ)、貪欲法で得られた解をベースに他の手法で更に良い解を探索したりといった方法で、更にスコアを伸ばしていくことも出来ます。
詳しくはコンテスト終了後の解説を参照してください。