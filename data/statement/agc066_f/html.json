{"html":{"ja":"<span class=\"lang-ja\">\n<p>配点 : <var>1600</var> 点</p>\n\n<div class=\"part\">\n<section>\n<h3>問題文</h3><p>次の条件を満たす文字列を，<strong>美しい文字列</strong>ということにします．</p>\n<ul>\n<li>どの文字も <code>A</code>, <code>B</code>, <code>C</code> のいずれかである．</li>\n<li>どの隣接する <var>2</var> 文字も相異なる．</li>\n</ul>\n<p>例えば <code>AB</code>, <code>BCAC</code> は美しい文字列です．<code>BB</code>, <code>CBAAC</code> は美しい文字列ではありません．</p>\n<hr>\n<p>美しい文字列 <var>S</var> が与えられます．あなたはこの文字列に対して，次の操作を繰り返し行うことができます：</p>\n<ul>\n<li>操作：<var>S</var> の隣接する <var>2</var> 文字をスワップする．ただしスワップ後の <var>S</var> も美しい文字列でなくてはならない．</li>\n</ul>\n<p>最終的な文字列 <var>S</var> としてありうる辞書順最小の文字列を求めてください．</p>\n<p><var>T</var> 個のテストケースが与えられるので，それぞれについて答えを求めてください．</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>制約</h3><ul>\n<li><var>1\\leq T\\leq 10^5</var></li>\n<li><var>S</var> は美しい文字列である．</li>\n<li><var>1\\leq |S|\\leq 10^6</var></li>\n<li><var>1</var> 個の入力に含まれるテストケースについて，それらの <var>|S|</var> の総和は <var>10^6</var> 以下である．</li>\n</ul>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>入力</h3><p>入力は以下の形式で標準入力から与えられます．</p>\n<pre><var>T</var>\n<var>\\text{case}_1</var>\n<var>\\vdots</var>\n<var>\\text{case}_T</var>\n</pre>\n\n<p>各テストケースは以下の形式で与えられます．</p>\n<pre><var>S</var>\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力</h3><p><var>T</var> 行出力してください．<var>i</var> 行目には <var>i</var> 番目のテストケースについて，最終的な文字列 <var>S</var> としてありうる辞書順最小の文字列を出力してください．</p>\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>入力例 1</h3><pre>8\nCAB\nACBCB\nB\nAC\nBACBA\nBABABA\nABCBCAC\nCBABACABCBABABC\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 1</h3><pre>ABC\nABCBC\nB\nAC\nABABC\nBABABA\nABCACBC\nABABACBCACBCBAB\n</pre>\n\n<p><var>1</var> 番目，<var>2</var> 番目のテストケースについて，次が <var>S</var> を辞書順最小化する方法の一例となります．</p>\n<ul>\n<li><code>CAB</code> → <code>ACB</code> → <code>ABC</code></li>\n<li><code>ACBCB</code> → <code>CABCB</code> → <code>CBACB</code> → <code>BCACB</code> → <code>BCABC</code> → <code>BACBC</code> → <code>ABCBC</code></li>\n</ul></section>\n</div>\n</span>","en":"<span class=\"lang-en\">\n<p>Score: <var>1600</var> points</p>\n\n<div class=\"part\">\n<section>\n<h3>Problem Statement</h3><p>A string is called a <strong>beautiful string</strong> if and only if it satisfies the following conditions:</p>\n<ul>\n<li>Every character is <code>A</code>, <code>B</code>, or <code>C</code>.</li>\n<li>No two adjacent characters are the same.</li>\n</ul>\n<p>For example, <code>AB</code> and <code>BCAC</code> are beautiful strings, while <code>BB</code> and <code>CBAAC</code> are not.</p>\n<hr>\n<p>You are given a beautiful string <var>S</var>. On this string, you can repeatedly perform the following operation.</p>\n<ul>\n<li>Operation: Swap two adjacent characters in <var>S</var>. Here, <var>S</var> must still be a beautiful string after the swap.</li>\n</ul>\n<p>Find the lexicographically smallest string that <var>S</var> can become.</p>\n<p><var>T</var> test cases are given; solve each of them.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Constraints</h3><ul>\n<li><var>1\\leq T\\leq 10^5</var></li>\n<li><var>S</var> is a beautiful string.</li>\n<li><var>1\\leq |S|\\leq 10^6</var></li>\n<li>The sum of <var>|S|</var> over all test cases in a single input is at most <var>10^6</var>.</li>\n</ul>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>Input</h3><p>The input is given from Standard Input in the following format:</p>\n<pre><var>T</var>\n<var>\\text{case}_1</var>\n<var>\\vdots</var>\n<var>\\text{case}_T</var>\n</pre>\n\n<p>Each test case is given in the following format:</p>\n<pre><var>S</var>\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Output</h3><p>Print <var>T</var> lines. The <var>i</var>-th line should contain the lexicographically smallest string that <var>S</var> can become for the <var>i</var>-th test case.</p>\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>Sample Input 1</h3><pre>8\nCAB\nACBCB\nB\nAC\nBACBA\nBABABA\nABCBCAC\nCBABACABCBABABC\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 1</h3><pre>ABC\nABCBC\nB\nAC\nABABC\nBABABA\nABCACBC\nABABACBCACBCBAB\n</pre>\n\n<p>For each of the first and second test cases, here is a possible way to lexicographically minimize <var>S</var>:</p>\n<ul>\n<li><code>CAB</code> → <code>ACB</code> → <code>ABC</code></li>\n<li><code>ACBCB</code> → <code>CABCB</code> → <code>CBACB</code> → <code>BCACB</code> → <code>BCABC</code> → <code>BACBC</code> → <code>ABCBC</code></li>\n</ul></section>\n</div>\n</span>"},"endpoint":"https://atcoder.jp/contests/agc066/tasks/agc066_f"}