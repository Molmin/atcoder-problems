{"html":{"ja":"<span class=\"lang-ja\">\n\n<div class=\"part\">\n<section>\n<h3>問題文</h3><p><var>N \\times N</var> のマス目で表される洞窟がある。\n一番左上のマスの座標を <var>(0,0)</var> とし、そこから下方向に <var>i</var> マス、右方向に <var>j</var> マス進んだ先のマスの座標を <var>(i,j)</var> とする。\n洞窟の周囲は壁で囲まれており、外に出ることはできない。</p>\n<p>洞窟内には岩と <var>M</var> 種類の鉱石が散らばっている。\nまた、洞窟内の異なる <var>M</var> 個のマスには穴があり、<var>i</var> 種類目の鉱石を全て <var>i</var> 番目の穴に落としたい。\n<strong>岩については、どの穴に落としてもよく、また洞窟内に放置してもよい。</strong>\nあなたは以下の操作を 最大で <var>10000</var> 回 行うことができる。</p>\n<ol>\n<li>上下左右に隣接するマスへ移動する。<strong>移動先に穴・岩・鉱石があっても移動できる。</strong></li>\n<li>現在位置にある岩・鉱石を上下左右に隣接するマスへ運ぶ。<strong>運ぶ先にすでに別の岩・鉱石があってはならない。運ぶ先は穴でもよい。</strong> 運んだ先が穴であった場合、岩・鉱石は穴に落ちて取り除かれる。あなたの現在位置は運んだ先のマスになる。</li>\n<li>現在位置にある岩・鉱石を、上下左右のいずれかの方向に転がす。転がした岩・鉱石は、岩・鉱石・壁にぶつかって止まるか、穴に落ちるまで一直線に転がる。あなたの現在位置は変化しない。</li>\n</ol>\n<p>転がす操作は、より詳細には以下の繰り返しによって処理される。</p>\n<ol>\n<li>転がっている方向に隣接するマスが穴である場合、岩・鉱石は穴に落ちて取り除かれる。</li>\n<li>転がっている方向に隣接するマスに岩・鉱石がある、または <var>N \\times N</var> の外に出る場合、現在のマスで停止する。</li>\n<li>上記のどちらにも該当しない場合、隣接するマスへ移動し、処理を繰り返す。</li>\n</ol>\n<p>転がる速度は非常に速いため、あなたの次の行動の前に必ず停止するか、穴に落ちて取り除かれる。</p>\n<p>できるだけ少ない行動回数ですべての鉱石を対応する穴に落としてほしい。</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>得点</h3><p>出力した行動列の長さを <var>T (\\leq 10000)</var>、初期盤面における鉱石の総数を <var>K</var>、正しい穴に落とすことができた鉱石の総数を <var>A</var> としたとき、以下の得点が得られる。</p>\n<ul>\n<li><var>A=K</var> の場合、<var>\\mathrm{round}(10^6\\times(1+\\log_2{\\frac{10000}{T}}))</var></li>\n<li><var>A&lt;K</var> の場合、<var>\\mathrm{round}(10^6\\times\\frac{A}{K})</var></li>\n</ul>\n<p>入力生成方法の違いにより、問題は A・B・C の 3 問 に分かれている。\nそれぞれの問題には 150 個のテストケース があり、各テストケースの得点の合計がその問題に対する提出の得点となる。\n一つ以上のテストケースで不正な出力や制限時間超過をした場合、提出全体の判定が<span class=\"label label-warning\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"不正解\">WA</span>や<span class=\"label label-warning\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"実行時間制限超過\">TLE</span>となる。\n各問題に対して獲得した最高得点の総和で最終順位が決定され、コンテスト終了後のシステムテストは行われない。 同じ得点を複数のチームが得た場合、提出時刻に関わらず同じ順位となる。</p>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>入力</h3><p>入力は以下の形式で標準入力から与えられる。</p>\n<pre><var>N</var> <var>M</var>\n<var>C_0</var>\n<var>\\vdots</var>\n<var>C_{N-1}</var>\n</pre>\n<ul>\n<li>盤面の大きさ <var>N</var> は、すべてのテストケースにおいて <var>N = 20</var> で固定されている。</li>\n<li>鉱石の種類数 <var>M</var> は、問題ごとに固定されている。詳しくは 「入力生成方法」 の項目を参照せよ。</li>\n<li>各 <var>i = 0, 1, \\dots, N-1</var> に対し、<var>C_i</var> は長さ <var>N</var> の文字列であり、その <var>j</var> 文字目は以下のようにマス <var>(i, j)</var> の初期状態を表す。<ul>\n<li><code>@</code>: 岩が存在する。</li>\n<li><code>a</code>-<code>z</code>: 鉱石が存在する。</li>\n<li><code>A</code>-<code>Z</code>: 穴が存在する。</li>\n<li><code>.</code>: 何も存在しない。</li>\n</ul>\n</li>\n</ul>\n<p>鉱石と穴はアルファベットの大文字・小文字が対応している。\nたとえば、文字 <code>a</code> で表される鉱石を落とすべき穴は、文字 <code>A</code> で表される。\n最初の <var>M</var> 個のアルファベットが使用され、同じ種類の鉱石は複数存在する可能性があるが、同じ種類の穴は必ず 1 つだけである。</p>\n<p>あなたは初期状態で穴 <code>A</code> のマスにいる。</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力</h3><p><var>t</var> 手目の操作は、行動の種類番号 <var>a_t \\in \\{1,2,3\\}</var> (1:移動、2:運ぶ、3:転がす) と上下左右の方向を表す文字 <var>d_t \\in \\{U,D,L,R\\}</var> のペア <var>(a_t, d_t)</var> で表される。\n例えば、<var>(3, R)</var> は現在位置にある岩・鉱石を右方向に転がす操作である。</p>\n<p>このとき、以下の形式で標準出力に出力せよ。</p>\n<pre><var>a_0</var> <var>d_0</var>\n<var>\\vdots</var>\n<var>a_{T-1}</var> <var>d_{T-1}</var>\n</pre>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>サンプルプログラム</h3><details>\nPython での解答例を示す。\nこのプログラムでは、初期位置の右にある岩・鉱石を穴に運び、初期位置の下にある岩・鉱石を穴に転がしている。\nそれ以外の岩・鉱石は手を付けずに放置する。\n\n<pre class=\"prettyprint linenums\">N, M = map(int, input().split())\ngrid = [list(input()) for _ in range(N)]\n\n# 現在位置の取得\npi = 0\npj = 0\nfor i in range(N):\n    for j in range(N):\n        if grid[i][j] == 'A':\n            pi = i\n            pj = j\n\n# 右方向に移動して岩・鉱石を見つけたら穴に運ぶ\nfor j in range(pj + 1, N):\n    if grid[pi][j] == '@' or 'a' &lt;= grid[pi][j] and grid[pi][j] &lt;= 'z':\n        print('1 R\\n' * (j - pj), end='')\n        print('2 L\\n' * (j - pj), end='')\n    elif 'A' &lt;= grid[pi][j] and grid[pi][j] &lt;= 'Z':\n        break\n\n# 下方向に移動して岩・鉱石を見つけたら穴に転がす\nfor i in range(pi + 1, N):\n    if grid[i][pj] == '@' or 'a' &lt;= grid[i][pj] and grid[i][pj] &lt;= 'z':\n        print('1 D\\n' * (i - pi), end='')\n        print('3 U\\n', end='')\n        pi = i\n    elif 'A' &lt;= grid[i][pj] and grid[i][pj] &lt;= 'Z':\n        break\n</pre>\n\n</details>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>入力生成方法</h3><p>入力生成方法は問題ごとに異なる。\n大まかには、以下の表のような入力が生成される。</p>\n<table class=\"table table-bordered\" style=\"width: auto;\">\n<thead>\n<tr>\n<th>問題</th>\n<th>M</th>\n<th>岩</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>1</td>\n<td>少ない</td>\n</tr>\n<tr>\n<td>B</td>\n<td>3</td>\n<td>存在しない</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>大量</td>\n</tr>\n</tbody>\n</table>\n\n<h4>A 問題</h4>\n<p><var>M = 1</var> で固定されている。</p>\n<ul>\n<li>穴 <code>A</code> の配置: <var>N^2</var> マスの中からランダムに 1 マス選択する。</li>\n<li>鉱石 <code>a</code> の配置: 残りの <var>N^2 - 1</var> マスの中からランダムに <var>2N</var> マス選択する。</li>\n<li>岩 <code>@</code> の配置: 残りの <var>N^2 - 1 - 2N</var> マスの中からランダムに <var>2N</var> マス選択する。</li>\n</ul>\n<h4>B 問題</h4>\n<p><var>M = 3</var> で固定されている。</p>\n<ul>\n<li>穴 <code>A</code>、<code>B</code>、<code>C</code> の配置: <var>N^2</var> マスの中から異なる 3 マスをランダムに選択する。</li>\n<li>鉱石 <code>a</code> の配置: 残りの <var>N^2 - 3</var> マスの中からランダムに <var>N</var> マス選択する。</li>\n<li>鉱石 <code>b</code> の配置: 残りの <var>N^2 - 3 - N</var> マスの中からランダムに <var>N</var> マス選択する。</li>\n<li>鉱石 <code>c</code> の配置: 残りの <var>N^2 - 3 - 2N</var> マスの中からランダムに <var>N</var> マス選択する。</li>\n</ul>\n<p>最後に、<strong>各穴から空きマスまたは対応する鉱石が存在するマスのみを通って、すべての対応する鉱石に到達可能である</strong>ことを確認する。\n到達不可能な鉱石がある場合、生成をやり直す。</p>\n<h4>C 問題</h4>\n<p><var>M = 1</var> で固定されている。</p>\n<ul>\n<li>岩 <code>@</code> の配置: 各マス <var>(i, j)</var> に対し、<var>h_{i,j} = \\mathrm{noise}(i/10, j/10)</var> を生成する。ここで、<var>\\mathrm{noise}(y, x)</var> は二次元の<a href=\"https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%83%AA%E3%83%B3%E3%83%8E%E3%82%A4%E3%82%BA\">Perlin noise</a>を生成する関数である。<var>h_{i,j}</var> の値が大きい順に上位 <var>N^2/2</var> マスに岩を配置する。</li>\n<li>穴 <code>A</code> の配置: 残りの <var>N^2/2</var> マスの中からランダムに 1 マス選択する。</li>\n<li>鉱石 <code>a</code> の配置: 残りの <var>N^2/2 - 1</var> マスの中からランダムに <var>2N</var> マス選択する。</li>\n</ul>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>ツール(入力ジェネレータ・スコア計算)</h3><ul>\n<li><a href=\"https://img.atcoder.jp/masters2025-qual/ioV2Ybuy.zip\">ローカル版</a>: 使用するには<a href=\"https://www.rust-lang.org/ja\">Rust言語</a>のコンパイル環境をご用意下さい。<ul>\n<li><a href=\"https://img.atcoder.jp/masters2025-qual/ioV2Ybuy_windows.zip\">Windows用のコンパイル済みバイナリ</a>: Rust言語の環境構築が面倒な方は代わりにこちらをご利用下さい。</li>\n</ul>\n</li>\n</ul>\n<p>コンテスト期間中に、チーム外とのビジュアライズ結果の共有や解法・考察に関する言及は禁止されています。ご注意下さい。</p>\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>入力例 1</h3><pre style=\"max-height:200px;overflow-y:scroll\">20 1\n..a.@....a.....a....\n..@........@..a.@a@.\n..aa...a..@.....a...\n.............a.....@\n.....@.a.....a@@....\n..a..a@..a......@...\n.@a.@aa...........a@\n...............@.a..\n.a......@@@.a.......\n........@.@..a.....a\n.a.A..a....@....a..@\n......@..@@.........\n..@@....a..@@.a.....\n......a.....@..a....\n...................a\n@@.....@....a.a.a...\n.....@.......a...@..\n...@......@...a....a\n............a..@....\n.......a.@..........\n</pre>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 1</h3><pre style=\"max-height:200px;overflow-y:scroll\">1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 D\n1 D\n3 U\n1 D\n1 D\n1 D\n1 D\n1 D\n3 U\n</pre></section>\n</div>\n</span>","en":"<span class=\"lang-en\">\n\n<div class=\"part\">\n<section>\n<h3>Problem Statement</h3><p>There is a cave represented by an <var>N \\times N</var> grid.\nLet <var>(0,0)</var> be the coordinates of the top-left square, and <var>(i,j)</var> be the coordinates of the square located <var>i</var> squares down and <var>j</var> squares to the right from there.\nThe cave is surrounded by walls, and it is not possible to move outside.</p>\n<p>Inside the cave, there are rocks and <var>M</var> types of ores scattered across the grid.\nAdditionally, there are <var>M</var> distinct squares that contain holes, and you need to drop all ores of type <var>i</var> into the <var>i</var>-th hole.\n<strong>Rocks may be dropped into any hole or left inside the cave.</strong>\nYou can perform the following operations at most <var>10000</var> times.</p>\n<ol>\n<li>Move to an adjacent square in any of the four directions (up, down, left, or right). <strong>You can move even if the destination square contains a hole, rock, or ore.</strong></li>\n<li>Carry a rock or ore at your current position to an adjacent square in any of the four directions. <strong>The destination must not already contain another rock or ore. The destination may be a hole.</strong> If the destination is a hole, the rock or ore falls into it and is removed. Your position moves to the destination square.</li>\n<li>Roll the rock or ore at your current position in one of the four directions. The rolled rock or ore continues moving in a straight line until it either collides with a rock, ore, or wall, or falls into a hole. Your position does not change.</li>\n</ol>\n<p>The rolling operation is processed in more detail through the following repeated steps:</p>\n<ol>\n<li>If the adjacent square in the rolling direction is a hole, the rock or ore falls into it and is removed.</li>\n<li>If the adjacent square in the rolling direction contains a rock or ore, or if it is outside the <var>N \\times N</var> grid, the rock or ore stops in the current square.</li>\n<li>Otherwise, it moves to the adjacent square and repeats the process.</li>\n</ol>\n<p>The rolling speed is very fast, so the rock or ore will always stop or fall into a hole before your next action.</p>\n<p>Your goal is to drop all ores into their corresponding holes using as few actions as possible.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Scoring</h3><p>Let <var>T (\\leq 10000)</var> be the length of the output action sequence, <var>K</var> be the total number of ores in the initial grid, and <var>A</var> be the total number of ores successfully dropped into the correct holes. The score is calculated as follows:</p>\n<ul>\n<li>If <var>A = K</var>, then the score is <var>\\mathrm{round}(10^6 \\times (1+\\log_2{\\frac{10000}{T}}))</var>.</li>\n<li>If <var>A &lt; K</var>, then the score is <var>\\mathrm{round}(10^6 \\times \\frac{A}{K})</var>.</li>\n</ul>\n<p>The problem is divided into three subproblems: A, B, and C, based on different input generation methods.\nEach subproblem contains 150 test cases, and the total score for a submission to that subproblem is the sum of the scores from all test cases in it.\nIf your submission produces an illegal output or exceeds the time limit for some test cases, the submission itself will be judged as <span class=\"label label-warning\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Wrong Answer\">WA</span> or <span class=\"label label-warning\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Time Limit Exceeded\">TLE</span> , and the score of the submission will be zero.</p>\n<p>The final ranking is determined by the sum of the highest scores obtained for each subproblem, and there will be no system test after the contest.\nIf more than one team gets the same score, they will be ranked in the same place regardless of the submission time.</p>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>Input</h3><p>Input is given from Standard Input in the following format:</p>\n<pre><var>N</var> <var>M</var>\n<var>C_0</var>\n<var>\\vdots</var>\n<var>C_{N-1}</var>\n</pre>\n<ul>\n<li>The grid size <var>N</var> is fixed at <var>N = 20</var> for all test cases.</li>\n<li>The number of ore types <var>M</var> is fixed for each subproblem. See the <strong>\"Input Generation\"</strong> section for details.</li>\n<li>For each <var>i = 0, 1, \\dots, N-1</var>, <var>C_i</var> is a string of length <var>N</var>, where the <var>j</var>-th character represents the initial state of square <var>(i, j)</var> as follows:<ul>\n<li><code>@</code>: A rock is present.</li>\n<li><code>a</code>-<code>z</code>: An ore is present.</li>\n<li><code>A</code>-<code>Z</code>: A hole is present.</li>\n<li><code>.</code>: The square is empty.</li>\n</ul>\n</li>\n</ul>\n<p>Ores and holes correspond based on uppercase and lowercase letters.\nFor example, an ore represented by the character <code>a</code> corresponds to the hole represented by the character <code>A</code>.\nThe first <var>M</var> letters of the alphabet are used. There may be multiple ores of the same type, but there is exactly one hole for each type.</p>\n<p>You start at the square containing hole <code>A</code> in the initial state.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Output</h3><p>The operation at step <var>t</var> is represented by a pair <var>(a_t, d_t)</var>, where <var>a_t \\in \\{1,2,3\\}</var> denotes the action type (1:Move, 2:Carry, 3:Roll), and <var>d_t \\in \\{U,D,L,R\\}</var> represents the direction (Up, Down, Left, Right).</p>\n<p>For example, <var>(3, R)</var> denotes the action of rolling the rock or ore at the current position to the right.</p>\n<p>Then, output to Standard Output in the following format.</p>\n<pre><var>a_0</var> <var>d_0</var>\n<var>\\vdots</var>\n<var>a_{T-1}</var> <var>d_{T-1}</var>\n</pre>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Solution</h3><details>\nA sample solution in Python is provided.\nThis program carries rocks or ores located to the right of the initial position into the hole and rolls rocks or ores located below the initial position into the hole.\nAll other rocks and ores are left untouched.\n\n<pre class=\"prettyprint linenums\">N, M = map(int, input().split())\ngrid = [list(input()) for _ in range(N)]\n\n# Retrieve the current position\npi = 0\npj = 0\nfor i in range(N):\n    for j in range(N):\n        if grid[i][j] == 'A':\n            pi = i\n            pj = j\n\n# Move to the right and carry any rock or ore found into the hole\nfor j in range(pj + 1, N):\n    if grid[pi][j] == '@' or 'a' &lt;= grid[pi][j] and grid[pi][j] &lt;= 'z':\n        print('1 R\\n' * (j - pj), end='')\n        print('2 L\\n' * (j - pj), end='')\n    elif 'A' &lt;= grid[pi][j] and grid[pi][j] &lt;= 'Z':\n        break\n\n# Move downward and roll any rock or ore found into the hole\nfor i in range(pi + 1, N):\n    if grid[i][pj] == '@' or 'a' &lt;= grid[i][pj] and grid[i][pj] &lt;= 'z':\n        print('1 D\\n' * (i - pi), end='')\n        print('3 U\\n', end='')\n        pi = i\n    elif 'A' &lt;= grid[i][pj] and grid[i][pj] &lt;= 'Z':\n        break\n</pre>\n\n</details>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Input Generation</h3><p>The input generation method differs for each subproblem.\nThe inputs are roughly generated as shown in the table below.</p>\n<table class=\"table table-bordered\" style=\"width: auto;\">\n<thead>\n<tr>\n<th>Subproblem</th>\n<th>M</th>\n<th>Rocks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>1</td>\n<td>Few</td>\n</tr>\n<tr>\n<td>B</td>\n<td>3</td>\n<td>None</td>\n</tr>\n<tr>\n<td>C</td>\n<td>1</td>\n<td>Many</td>\n</tr>\n</tbody>\n</table>\n\n<h4>Subproblem A</h4>\n<p><var>M = 1</var> is fixed.</p>\n<ul>\n<li>Placement of hole <code>A</code>: Randomly select one square from the <var>N^2</var> squares.</li>\n<li>Placement of ore <code>a</code>: Randomly select <var>2N</var> squares from the remaining <var>N^2 - 1</var> squares.</li>\n<li>Placement of rocks <code>@</code>: Randomly select <var>2N</var> squares from the remaining <var>N^2 - 1 - 2N</var> squares.</li>\n</ul>\n<hr>\n<h4>Subproblem B</h4>\n<p><var>M = 3</var> is fixed.</p>\n<ul>\n<li>Placement of holes <code>A</code>, <code>B</code>, and <code>C</code>: Randomly select three distinct squares from the <var>N^2</var> squares.</li>\n<li>Placement of ore <code>a</code>: Randomly select <var>N</var> squares from the remaining <var>N^2 - 3</var> squares.</li>\n<li>Placement of ore <code>b</code>: Randomly select <var>N</var> squares from the remaining <var>N^2 - 3 - N</var> squares.</li>\n<li>Placement of ore <code>c</code>: Randomly select <var>N</var> squares from the remaining <var>N^2 - 3 - 2N</var> squares.</li>\n</ul>\n<p>Finally, ensure that <strong>from each hole, it is possible to reach all corresponding ores by passing only through empty squares or squares containing that ore.</strong>\nIf there exists an ore that is unreachable, the generation process is repeated.</p>\n<hr>\n<h4>Subproblem C</h4>\n<p><var>M = 1</var> is fixed.</p>\n<ul>\n<li>\n<p>Placement of rocks <code>@</code>: For each square <var>(i, j)</var>, generate <var>h_{i,j} = \\mathrm{noise}(i/10, j/10)</var>. Here, <var>\\mathrm{noise}(y, x)</var> is a function that generates two-dimensional <a href=\"https://en.wikipedia.org/wiki/Perlin_noise\">Perlin noise</a>. The top <var>N^2/2</var> squares with the highest <var>h_{i,j}</var> values are assigned rocks.</p>\n</li>\n<li>\n<p>Placement of hole <code>A</code>: Randomly select one square from the remaining <var>N^2/2</var> squares.</p>\n</li>\n<li>Placement of ore <code>a</code>: Randomly select <var>2N</var> squares from the remaining <var>N^2/2 - 1</var> squares.</li>\n</ul>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Tools (Input generator and score calculation)</h3><ul>\n<li><a href=\"https://img.atcoder.jp/masters2025-qual/ioV2Ybuy.zip\">Local version</a>: You need a compilation environment of <a href=\"https://www.rust-lang.org/\">Rust language</a>.<ul>\n<li><a href=\"https://img.atcoder.jp/masters2025-qual/ioV2Ybuy_windows.zip\">Pre-compiled binary for Windows</a>: If you are not familiar with the Rust language environment, please use this instead.</li>\n</ul>\n</li>\n</ul>\n<p>Please be aware that sharing visualization results or discussing solutions/ideas outside of the team during the contest is prohibited.</p>\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>Sample Input 1</h3><pre style=\"max-height:200px;overflow-y:scroll\">20 1\n..a.@....a.....a....\n..@........@..a.@a@.\n..aa...a..@.....a...\n.............a.....@\n.....@.a.....a@@....\n..a..a@..a......@...\n.@a.@aa...........a@\n...............@.a..\n.a......@@@.a.......\n........@.@..a.....a\n.a.A..a....@....a..@\n......@..@@.........\n..@@....a..@@.a.....\n......a.....@..a....\n...................a\n@@.....@....a.a.a...\n.....@.......a...@..\n...@......@...a....a\n............a..@....\n.......a.@..........\n</pre>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 1</h3><pre style=\"max-height:200px;overflow-y:scroll\">1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n1 R\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n2 L\n1 D\n1 D\n3 U\n1 D\n1 D\n1 D\n1 D\n1 D\n3 U\n</pre></section>\n</div>\n</span>"},"endpoint":"https://atcoder.jp/contests/masters2025-qual/tasks/masters2025_qual_a"}