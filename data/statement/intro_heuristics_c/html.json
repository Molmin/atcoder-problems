{"html":{"ja":"<span class=\"lang-ja\">\n<p>(まずは問題Aを先に読んでください。この問題を解くことで得られる得点は1点です。順位にはほぼ影響しません。)</p>\n\n<div class=\"part\">\n<section>\n<h3>入門者向けガイド</h3><p>出来るだけ良い解を求めるための非常に強力な手法の一つが「局所探索法」です。\nこの手法では、闇雲に一から解を探すのではなく、既に見つけた解を少し変化させることで、より良い解に出来ないかを試します。\n解が良くなっていれば更新し、悪くなってしまったら元に戻します。\nこの操作を繰り返し反復することで、時間をかけて徐々に解の質を高めていきます。\n疑似コードで表すと以下のようになります。</p>\n<pre>solution = 初期解(ランダム生成や、貪欲法など他の手法で求めたものを利用)\nwhile 時間のある限り:\n    solution を(ランダムに)少し変形\n    if 変形前より解が悪化:\n        solution を変形前の状態に戻す\n</pre>\n\n<p>例えばこの問題の場合、変形操作として「日付 <var>d</var> とコンテストタイプ <var>q</var> をランダムに選び、<var>d</var> 日目に開催するコンテストをタイプ <var>q</var> に変更する」というものを考えることが出来ます。\n疑似コードで表すと以下のようになります。</p>\n<pre>t[1..D] = 初期解(ランダム生成や、貪欲法で求めたものを利用)\nwhile 時間のある限り:\n    d と q をランダムに選ぶ。\n    old = t[d] # 後で戻せるように元の値を記憶しておく\n    t[d] = q\n    if 変形前より解が悪化:\n        t[d] = old\n</pre>\n\n<p>局所探索法を用いる上で最も重要なことは、どのように変形を行うかの設計です。</p>\n<ol>\n<li>変化させる量が小さすぎるとすぐに行き止まり(局所最適解)に陥ってしまい、逆に、変化させる量が大きすぎると闇雲に探す状態に近くなって、改善できる確率が低くなってしまう。</li>\n<li>反復回数を増やすために、変形後のスコアが高速に計算出来ることが望ましい。</li>\n</ol>\n<p>この問題Cでは特に2番目の点に挑戦します。\n変形後のスコアはもちろん一からスコア計算を行うことで計算が可能ですが、変化のあった部分だけに着目して変形前からの差分を計算することで、より高速に行うことができる可能性があります。\n逆に、そのような高速化が出来ないということは部分的な変更がスコア計算の大部分に影響を与えているということであり、変形操作の見直しが必要であったり、そもそも局所探索には向いていない問題である可能性が高まります。\nさて、高速な差分計算に挑戦してみましょう。\nABCやARCなどで培ったアルゴリズムやデータ構造の力を発揮するチャンスです。</p>\n<p>今回のような最適解ではなく出来るだけ良い解を求めるタイプのコンテストでは、バグのあるプログラムを提出しても不正解とはならないため、バグに気づくのが遅れる可能性があります。\nバグの早期発見のために、複雑な処理を実装した箇所に対しては単体テストをしておくのも一つの手です。\n例えばスコアの差分計算を行う場合は、この問題Cのような形で、一からスコアを計算した場合と一致することをテストしておくと良いでしょう。</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>問題文</h3><p><var>D</var> 日分のコンテストの日程と、<var>M</var> 回の日程の変更クエリが与えられます。\n<var>i</var> 番目のクエリでは整数 <var>d_i</var> と <var>q_i</var> が与えられるので、<var>d_i</var> 日目に行うコンテストのタイプを <var>q_i</var> に変更し、変更後の日程における最終的な満足度を出力してください。\n注意: 変更はクエリ後も継続します。つまり <var>i</var> 番目のクエリは <var>(i-1)</var> 番目のクエリでの変更後の日程に対して適用します。</p>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>入力</h3><p>入力は問題Aの入力の末尾に問題Aの出力とクエリの情報が続く形で与えられる。</p>\n<pre><var>D</var>\n<var>c_1</var> <var>c_2</var> <var>\\cdots</var> <var>c_{26}</var>\n<var>s_{1,1}</var> <var>s_{1,2}</var> <var>\\cdots</var> <var>s_{1,26}</var>\n<var>\\vdots</var>\n<var>s_{D,1}</var> <var>s_{D,2}</var> <var>\\cdots</var> <var>s_{D,26}</var>\n<var>t_1</var>\n<var>t_2</var>\n<var>\\vdots</var>\n<var>t_D</var>\n<var>M</var>\n<var>d_1</var> <var>q_1</var>\n<var>d_2</var> <var>q_2</var>\n<var>\\vdots</var>\n<var>d_M</var> <var>q_M</var>\n</pre>\n\n<ul>\n<li>問題Aの入力に該当する部分の制約及び生成方法は問題Aのものと同じである。</li>\n<li>問題Aの出力に該当する部分は、各 <var>d</var> について <var>1\\leq t_d \\leq 26</var> を満たし、範囲内から一様ランダムに生成される。</li>\n<li>クエリ数 <var>M</var> は <var>1\\leq M\\leq 10^5</var> を満たす整数値。</li>\n<li>各 <var>d_i</var> は <var>1\\leq d_i\\leq D</var> を満たす整数値で、範囲内から一様ランダムに生成される。</li>\n<li>各 <var>q_i</var> は <var>1\\leq q_i\\leq 26</var> を満たす整数値で、クエリ時点での日程における <var>d_i</var> 日目のコンテストのタイプと異なる 25 個の値の中から一様ランダムに生成される。</li>\n</ul>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力</h3><p><var>i</var> 番目のクエリを処理した後の日程における最終的な満足度を <var>v_i</var> としたとき、以下のフォーマットで出力せよ。</p>\n<pre><var>v_1</var>\n<var>v_2</var>\n<var>\\vdots</var>\n<var>v_M</var>\n</pre>\n\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>入力例 1</h3><pre>5\n86 90 69 51 2 96 71 47 88 34 45 46 89 34 31 38 97 84 41 80 14 4 50 83 7 82\n19771 12979 18912 10432 10544 12928 13403 3047 10527 9740 8100 92 2856 14730 1396 15905 6534 4650 11469 3628 8433 2994 10899 16396 18355 11424\n6674 17707 13855 16407 12232 2886 11908 1705 5000 1537 10440 10711 4917 10770 17272 15364 19277 18094 3929 3705 7169 6159 18683 15410 9092 4570\n6878 4239 19925 1799 375 9563 3445 5658 19857 11401 6997 6498 19933 3848 2426 2146 19745 16880 17773 18359 3921 14172 16730 11157 5439 256\n8633 15862 15303 10749 18499 7792 10317 5901 9395 11433 3514 3959 5202 19850 19469 9790 5653 784 18500 10552 17975 16615 7852 197 8471 7452\n19855 17918 7990 10572 4333 438 9140 9104 12622 4985 12319 4028 19922 12132 16259 17476 2976 547 19195 19830 16285 4806 4471 9457 2864 2192\n1\n17\n13\n14\n13\n5\n1 7\n4 11\n3 4\n5 24\n4 19\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 1</h3><pre>72882\n56634\n38425\n27930\n42884\n</pre>\n\n<p>注意: この入出力例は問題仕様の確認用の小さいもので、制約 <var>D=365</var> を満たしておらず、実際にテストケースとして与えられることはない。</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>次のステップ</h3><p>問題Aに戻って局所探索法による解答を実装をしてみましょう。\nこの問題の場合、「日付 <var>d</var> とコンテストタイプ <var>q</var> をランダムに選び、<var>d</var> 日目に開催するコンテストをタイプ <var>q</var> に変更する」という変形操作は実はあまり良くありません。\nなぜ良くないかを考え、別の変形操作に改良してみましょう。\n局所探索法の改良版として、悪化する変形を確率的に受け入れることで優れた解に到達しやすくした「焼きなまし法」がよく用いられます。\n他の変形操作の例と焼きなまし法やその他の局所探索法についてはコンテスト終了後の解説を参照してください。</p></section>\n</div>\n</span>","en":"<span class=\"lang-en\">\n<p>(Please read problem A first. The maximum score you can get by solving this problem C is 1, which will have almost no effect on your ranking.)</p>\n\n<div class=\"part\">\n<section>\n<h3>Beginner's Guide</h3><p>\"Local search\" is a powerful method for finding a high-quality solution.\nIn this method, instead of constructing a solution from scratch, we try to find a better solution by slightly modifying the already found solution.\nIf the solution gets better, update it, and if it gets worse, restore it.\nBy repeating this process, the quality of the solution is gradually improved over time.\nThe pseudo-code is as follows.</p>\n<pre>solution = compute an initial solution (by random generation, or by applying other methods such as greedy)\nwhile the remaining time &gt; 0:\n    slightly modify the solution (randomly)\n    if the solution gets worse:\n        restore the solution\n</pre>\n\n<p>For example, in this problem, we can use the following modification: pick the date <var>d</var> and contest type <var>q</var> at random and change the type of contest to be held on day <var>d</var> to <var>q</var>.\nThe pseudo-code is as follows.</p>\n<pre>t[1..D] = compute an initial solution (by random generation, or by applying other methods such as greedy)\nwhile the remaining time &gt; 0:\n    pick d and q at random\n    old = t[d] # Remember the original value so that we can restore it later\n    t[d] = q\n    if the solution gets worse:\n        t[d] = old\n</pre>\n\n<p>The most important thing when using the local search method is the design of how to modify solutions.</p>\n<ol>\n<li>If the amount of modification is too small, we will soon fall into a dead-end (local optimum) and, conversely, if the amount of modification is too large, the probability of finding an improving move becomes extremely small.</li>\n<li>In order to increase the number of iterations, it is desirable to be able to quickly calculate the score after applying a modification.</li>\n</ol>\n<p>In this problem C, we focus on the second point.\nThe score after the modification can, of course, be obtained by calculating the score from scratch.\nHowever, by focusing on only the parts that have been modified, it may be possible to quickly compute the difference between the scores before and after the modification.\nFrom another viewpoint, the impossibility of such a fast incremental calculation implies that a small modification to the solution affects a majority of the score calculation.\nIn such a case, we may need to redesign how to modify solutions, or there is a high possibility that the problem is not suitable for local search.\nLet's implement fast incremental score computation.\nIt's time to demonstrate the skills of algorithms and data structures you have developed in ABC and ARC!</p>\n<p>In this kind of contest, where the objective is to find a better solution instead of the optimal one, a bug in a program does not result in a wrong answer, which may delay the discovery of the bug.\nFor early detection of bugs, it is a good idea to unit test functions you implemented complicated routines.\nFor example, if you implement fast incremental score calculation, it is a good idea to test that the scores computed by the fast implementation match the scores computed from scratch, as we will do in this problem C.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Problem Statement</h3><p>You will be given a contest schedule for <var>D</var> days and <var>M</var> queries of schedule modification.\nIn the <var>i</var>-th query, given integers <var>d_i</var> and <var>q_i</var>, change the type of contest to be held on day <var>d_i</var> to <var>q_i</var>, and then output the final satisfaction at the end of day <var>D</var> on the updated schedule.\nNote that we do not revert each query. That is, the <var>i</var>-th query is applied to the new schedule obtained by the <var>(i-1)</var>-th query.</p>\n</section>\n</div>\n\n<hr>\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>Input</h3><p>Input is given from Standard Input in the form of the input of Problem A followed by the output of Problem A and the queries.</p>\n<pre><var>D</var>\n<var>c_1</var> <var>c_2</var> <var>\\cdots</var> <var>c_{26}</var>\n<var>s_{1,1}</var> <var>s_{1,2}</var> <var>\\cdots</var> <var>s_{1,26}</var>\n<var>\\vdots</var>\n<var>s_{D,1}</var> <var>s_{D,2}</var> <var>\\cdots</var> <var>s_{D,26}</var>\n<var>t_1</var>\n<var>t_2</var>\n<var>\\vdots</var>\n<var>t_D</var>\n<var>M</var>\n<var>d_1</var> <var>q_1</var>\n<var>d_2</var> <var>q_2</var>\n<var>\\vdots</var>\n<var>d_M</var> <var>q_M</var>\n</pre>\n\n<ul>\n<li>The constraints and generation methods for the input part are the same as those for Problem A.</li>\n<li>For each <var>d=1,\\ldots,D</var>, <var>t_d</var> is an integer generated independently and uniformly at random from <var>{1,2,\\ldots,26}</var>.</li>\n<li>The number of queries <var>M</var> is an integer satisfying <var>1\\leq M\\leq 10^5</var>.</li>\n<li>For each <var>i=1,\\ldots,M</var>, <var>d_i</var> is an integer generated independently and uniformly at random from <var>{1,2,\\ldots,D}</var>.</li>\n<li>For each <var>i=1,\\ldots,26</var>, <var>q_i</var> is an integer satisfying <var>1\\leq q_i\\leq 26</var> generated uniformly at random from the <var>25</var> values that differ from the type of contest on day <var>d_i</var>.</li>\n</ul>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Output</h3><p>Let <var>v_i</var> be the final satisfaction at the end of day <var>D</var> on the schedule after applying the <var>i</var>-th query.\nPrint <var>M</var> integers <var>v_i</var> to Standard Output in the following format:</p>\n<pre><var>v_1</var>\n<var>v_2</var>\n<var>\\vdots</var>\n<var>v_M</var>\n</pre>\n\n</section>\n</div>\n</div>\n\n<hr>\n<div class=\"part\">\n<section>\n<h3>Sample Input 1</h3><pre>5\n86 90 69 51 2 96 71 47 88 34 45 46 89 34 31 38 97 84 41 80 14 4 50 83 7 82\n19771 12979 18912 10432 10544 12928 13403 3047 10527 9740 8100 92 2856 14730 1396 15905 6534 4650 11469 3628 8433 2994 10899 16396 18355 11424\n6674 17707 13855 16407 12232 2886 11908 1705 5000 1537 10440 10711 4917 10770 17272 15364 19277 18094 3929 3705 7169 6159 18683 15410 9092 4570\n6878 4239 19925 1799 375 9563 3445 5658 19857 11401 6997 6498 19933 3848 2426 2146 19745 16880 17773 18359 3921 14172 16730 11157 5439 256\n8633 15862 15303 10749 18499 7792 10317 5901 9395 11433 3514 3959 5202 19850 19469 9790 5653 784 18500 10552 17975 16615 7852 197 8471 7452\n19855 17918 7990 10572 4333 438 9140 9104 12622 4985 12319 4028 19922 12132 16259 17476 2976 547 19195 19830 16285 4806 4471 9457 2864 2192\n1\n17\n13\n14\n13\n5\n1 7\n4 11\n3 4\n5 24\n4 19\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 1</h3><pre>72882\n56634\n38425\n27930\n42884\n</pre>\n\n<p>Note that this example is a small one for checking the problem specification. It does not satisfy the constraint <var>D=365</var> and is never actually given as a test case.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Next Step</h3><p>Let's go back to Problem A and implement the local search algorithm by utilizing the incremental score calculator you just implemented!\nFor this problem, the current modification \"pick the date <var>d</var> and contest type <var>q</var> at random and change the type of contest to be held on day <var>d</var> to <var>q</var>\" is actually not so good. By considering why it is not good, let's improve the modification operation.\nOne of the most powerful and widely used variant of the local search method is \"Simulated Annealing (SA)\", which makes it easier to reach a better solution by stochastically accepting worsening moves.\nFor more information about SA and other local search techniques, please refer to the editorial that will be published after the contest.</p></section>\n</div>\n</span>"},"endpoint":"https://atcoder.jp/contests/intro-heuristics/tasks/intro_heuristics_c"}